## lab1
读完源代码之后，发现主要是需要自己实现获取系统调用以及次数和任务总运行时长
想到在TaskControlBlock这个结构体当中添加相关的两个字段，分别为
- `time` :记录时间
- `syscall_times`:记录次数

然后在os/src/task/mod.rs中对`TaskManager`实现`get_task_info`与`increase_syscall_time`方法，并对任务调度的`run_first_task`、`mark_current_exited`、`run_next_task`进行相应的时间戳更新，以及`os/src/trap/mod.rs`中进行系统调用的更新，就可以了
#### 遇到的问题:
- 一开始系统调用计数一直是0，然后通过打印发现在累加函数内确实实现了累加，但是出去后还是0，后面反应过来应该是获取可变引用进行累加操作才能改变系统调用的计数
- 一开始使用的栈，但是初始化的时候会爆栈，猜测是内核代码的区域大小有限制，所以用Box包裹在储存堆上。


## lab2
#### 重写sys_get_time和sys_task_info
引入虚拟地址空间后,程序在系统调用时,传入的虚拟地址,而在内核地址空间中,这个地址无法被找到,所以要进行相应的转化
- 在`os/src/syscall/process.rs`中加入一个`translate`方法，该方法接受虚拟地址作为参数并返回该虚拟地址对应的物理地址
- 重写`sys_get_time`时，增加了从用户态虚拟地址写入物理地址的功能，使用实现的`translate`方法就可以
- `sys_task_info`差不多，也是转换一下地址就好了
	
#### mmap和munmap匿名映射
- 对于mmap,先检查输入权限是否合法，如果合法，则开始创建虚拟内存映射，并返回创建虚拟地址内存映射成功，这里还维护了一个`includes`函数，用来检查在`area`字段中是否存在一个区域包含`vr`，存在则返回`true`。在mmap中，先通过传入参数计算`vr`，然后进行判断，不存在则新建一个`MapArea`push到`MemerySet`中

- 对于munmap,要查询是否存在需要删除的MapArea,如果有，则进行删除，否则返回删除失败，注意这里先检查起始地址是否合法(即对齐)

- 注意对于mmap，其实也要判断起始地址是否合法，但这里先写在了`sys_mmap`中，所以在mmap中就没有，munmap中就直接先判断了起始地址是否合法，所以sys_munmap中就没有。(其实可以集成的，但是后面都git上去了，就没改了)

#### 遇到的问题:
- 文档里提到的port和内核定义的MapPermission的语义有明显不同，需要注意




## lab3
#### 实现spawn
根据文档的提示spawn的实现参考fork和exec，看了C语言的spawn的实现后，直接将fork和exec的代码串起来，然后参考C语言的实现对串起来的代码进行了一定的更改，主要的点在于初始化新进程的进程控制块。

#### 实现set_priority
在实现`set_priority`时，在`TaskControlBlockInner` 中加入了`stride`和`priority`，在进程调度中，使用了文档里面提到过堆结构，在进程组成的堆中找到最小`stride`的进程，然后更新该进程的`stride`值，再fetch出。注意这里要为`TaskControlBlock`实现`PartialEq`、`PartialOrd`、`Eq`、`Ord`等`trait`。(为了使得 `TaskControlBlock` 之间能够进行比较。)

#### 遇到的问题
- 一开始没有想到要为`TaskControlBlock`实现那些`trait`，发现`stride`没办法比较。


## lab4
#### 分析
需要实现的系统调用包括`linkat`、`unlinkat`和`fstat`，分别实现创建一个文件的硬链接、取消一个文件路径到文件的链接以及获取文件的状态三个功能。这三个功能所经过的部分从系统调用层`syscall`指向内核索引结点层`OSInode`的相关操作，再指向`easy-fs`中`vfs`的`Inode`层的相关操作，最后指向efs中的相应磁盘索引节点的相关操作。

#### 具体实现
- `linkat`：对于linkat的思路是在文件的根目录节点上找到oldpath对应的文件索引节点oldinode，然后再用该inode创建一个除了目录项的字符名称为newpath、其他信息完全一样的文件索引节点插入到根目录节点中。
- `unlinkat`:对于unlinkat，需要在文件的根目录节点上找到name对应的文件索引节点inode，然后将该inode从根目录中清空即可。
- `fstat`:`dev`、`ino`、`mode`和`pad`字段都比较好实现。对于`nlink`字段可以在文件的根目录节点上找到所有对应inode值的节点计数来实现，这个的实现是在`easy-fs/vfs.rs`加入了一个`count_link`方法，然后在stat的实现中调用就好了。另外为了方便，还维护了一个`get_id`方法，方便在stat中直接拿到`inode_id` 并传给`count_link`获得硬链接数量。

#### 遇到的问题
- 本章啃`easy-fs`的代码、理清代码之间的逻辑花了不少时间，很好奇这个文件系统怎么写入内核的，后面看文档发现是在driver里面，然后通过镜像打包扔进去的(可以通过Makefile看出)
- 一开始不确定把`Stat`结构放到哪里，`OSInode` / `Inode` / `Dirent` / `DiskInode`


## lab5

起初在想这个问题的时候，因为使用的是银行家算法，一直在纠结如何得到这个需求矩阵。然后看了一眼应用程序，发现应用程序中没有对需求矩阵进行直接输入，于是我想唯一的办法就是在线程申请资源的时候动态更新需求矩阵。

后来加入了分配矩阵和资源剩余矩阵（都储存在进程控制块中），逻辑就是：

- 在申请资源的时候，先更新需求矩阵，分析死锁与否，然后在线程拿到资源后，再更新分配矩阵和资源剩余矩阵；
- 在释放资源的时候，同时更新需求矩阵，分配矩阵和资源剩余矩阵
- 分析死锁时，只分析是否有线程还能够被满足，如果有线程能够被满足，就继续进行下去。如果当所有线程都处于无法被满足状态，那么就发生了死锁。但由于这个过程是动态的（需求矩阵动态变化），因此可能一开始并不能检测到死锁，直到后来才能发现死锁。


#### 遇到的问题

- 一开始跑测例不通过，之后调整日志等级发现还是需要把`sys_get_time`加上会更好
- 银行家算法的应用场景